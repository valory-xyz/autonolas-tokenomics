From 35299214006b3a181b981554e025342ee23ee90c Mon Sep 17 00:00:00 2001
From: Aleksandr Kuperman <aleksandr.kuperman@valory.xyz>
Date: Tue, 6 Jan 2026 15:42:27 +0000
Subject: [PATCH 1/6] refactor: swap symmetry for V2 and V3 in BBB

---
 contracts/oracles/BalancerPriceOracle.sol |  10 +-
 contracts/oracles/UniswapPriceOracle.sol  |   4 +-
 contracts/utils/BuyBackBurner.sol         | 140 +++++++++++++---------
 contracts/utils/BuyBackBurnerBalancer.sol |  43 +++++--
 contracts/utils/BuyBackBurnerUniswap.sol  |  15 +--
 5 files changed, 131 insertions(+), 81 deletions(-)

diff --git a/contracts/oracles/BalancerPriceOracle.sol b/contracts/oracles/BalancerPriceOracle.sol
index 06c8b3e1..57eae0ed 100644
--- a/contracts/oracles/BalancerPriceOracle.sol
+++ b/contracts/oracles/BalancerPriceOracle.sol
@@ -32,8 +32,8 @@ contract BalancerPriceOracle {
     uint256 public immutable minUpdateTimePeriod;
     // LP token direction
     uint256 public immutable direction;
-    // Native token (ERC-20) address
-    address public immutable nativeToken;
+    // Second token address in pool
+    address public immutable secondToken;
     // OLAS token address
     address public immutable olas;
     // Balancer vault address
@@ -43,7 +43,7 @@ contract BalancerPriceOracle {
 
     constructor(
         address _olas,
-        address _nativeToken,
+        address _secondToken,
         uint256 _maxSlippage,
         uint256 _minUpdateTimePeriod,
         address _balancerVault,
@@ -52,7 +52,7 @@ contract BalancerPriceOracle {
         require(_maxSlippage < 100, "Slippage must be less than 100%");
 
         olas = _olas;
-        nativeToken = _nativeToken;
+        secondToken = _secondToken;
         maxSlippage = _maxSlippage;
         minUpdateTimePeriod = _minUpdateTimePeriod;
         balancerVault = _balancerVault;
@@ -60,7 +60,7 @@ contract BalancerPriceOracle {
 
         // Get token direction
         (address[] memory tokens, , ) = IVault(balancerVault).getPoolTokens(_balancerPoolId);
-        if (tokens[0] != _nativeToken) {
+        if (tokens[0] != _secondToken) {
             direction = 1;
         }
 
diff --git a/contracts/oracles/UniswapPriceOracle.sol b/contracts/oracles/UniswapPriceOracle.sol
index 85e7bcb8..57ececf9 100644
--- a/contracts/oracles/UniswapPriceOracle.sol
+++ b/contracts/oracles/UniswapPriceOracle.sol
@@ -20,13 +20,13 @@ contract UniswapPriceOracle {
     // LP token direction
     uint256 public immutable direction;
 
-    constructor(address _nativeToken, uint256 _maxSlippage, address _pair) {
+    constructor(address _secondToken, uint256 _maxSlippage, address _pair) {
         pair = _pair;
         maxSlippage = _maxSlippage;
 
         // Get token direction
         address token0 =  IUniswapV2(pair).token0();
-        if (token0 != _nativeToken) {
+        if (token0 != _secondToken) {
             direction = 1;
         }
     }
diff --git a/contracts/utils/BuyBackBurner.sol b/contracts/utils/BuyBackBurner.sol
index 5c5cb922..d369ac22 100644
--- a/contracts/utils/BuyBackBurner.sol
+++ b/contracts/utils/BuyBackBurner.sol
@@ -56,6 +56,10 @@ error ZeroValue();
 /// @dev The contract is already initialized.
 error AlreadyInitialized();
 
+/// @dev Unauthorized pool address.
+/// @param pool Pool address.
+error UnauthorizedPool(address pool);
+
 // @dev Reentrancy guard.
 error ReentrancyGuard();
 
@@ -63,8 +67,8 @@ error ReentrancyGuard();
 abstract contract BuyBackBurner {
     event ImplementationUpdated(address indexed implementation);
     event OwnerUpdated(address indexed owner);
-    event OracleUpdated(address indexed oracle);
-    event BuyBack(address indexed token, uint256 tokenAmount, uint256 olasAmount);
+    event OraclesUpdated(address[] secondTokens, address[] oracles);
+    event BuyBack(address indexed secondToken, uint256 secondTokenAmount, uint256 olasAmount);
     event OraclePriceUpdated(address indexed oracle, address indexed sender);
     event TokenTransferred(address indexed destination, uint256 amount);
 
@@ -88,7 +92,7 @@ abstract contract BuyBackBurner {
     // Oracle address
     address public oracle;
 
-    // Oracle max slippage for ERC-20 native token <=> OLAS
+    // Oracle max slippage for second token <=> OLAS
     uint256 public maxSlippage;
     // Reentrancy lock
     uint256 internal _locked = 1;
@@ -105,6 +109,11 @@ abstract contract BuyBackBurner {
     // Concentrated liquidity swap router address
     address public immutable swapRouter;
 
+    // Map of second token address => whitelisted V2 oracle address
+    mapping(address => address) public mapV2Oracles;
+    // Map of V3 pool address => whitelisted status
+    mapping(address => bool) public mapV3Pools;
+
     /// @dev BuyBackBurner constructor.
     /// @param _liquidityManager LiquidityManager address.
     /// @param _bridge2Burner Bridge2Burner address.
@@ -130,16 +139,18 @@ abstract contract BuyBackBurner {
     function _initialize(bytes memory payload) internal virtual;
 
     /// @dev Performs swap for OLAS on V2 DEX.
-    /// @param nativeTokenAmount Native token amount.
+    /// @param secondToken Second token address.
+    /// @param secondTokenAmount Second token amount.
+    /// @param poolOracle Pool oracle address.
     /// @return olasAmount Obtained OLAS amount.
-    function _performSwap(uint256 nativeTokenAmount) internal virtual returns (uint256 olasAmount);
+    function _performSwap(address secondToken, uint256 secondTokenAmount, address poolOracle) internal virtual returns (uint256 olasAmount);
 
     /// @dev Performs swap for OLAS on V3 DEX.
-    /// @param token Token address.
-    /// @param tokenAmount Token amount.
+    /// @param secondToken Second token address.
+    /// @param secondTokenAmount Second token amount.
     /// @param feeTierOrTickSpacing Fee tier or tick spacing.
     /// @return olasAmount Obtained OLAS amount.
-    function _performSwap(address token, uint256 tokenAmount, int24 feeTierOrTickSpacing)
+    function _performSwap(address secondToken, uint256 secondTokenAmount, int24 feeTierOrTickSpacing)
         internal
         virtual
         returns (uint256 olasAmount);
@@ -156,20 +167,27 @@ abstract contract BuyBackBurner {
         returns (address);
 
     /// @dev Buys OLAS on V2 DEX.
-    /// @param nativeTokenAmount Native token amount.
+    /// @param secondToken Second token address.
+    /// @param secondTokenAmount Second token amount.
     /// @return olasAmount Obtained OLAS amount.
-    function _buyOLAS(uint256 nativeTokenAmount) internal virtual returns (uint256 olasAmount) {
+    function _buyOLAS(address secondToken, uint256 secondTokenAmount) internal virtual returns (uint256 olasAmount) {
+        // Get oracle address
+        address poolOracle = mapV2Oracles[secondToken];
+
+        // Check for zero address
+        require (poolOracle != address(0), "Zero oracle address");
+
         // Apply slippage protection
-        require(IOracle(oracle).validatePrice(maxSlippage), "Before swap slippage limit is breached");
+        require(IOracle(poolOracle).validatePrice(maxSlippage), "Before swap slippage limit is breached");
 
         // Get current pool price
-        uint256 previousPrice = IOracle(oracle).getPrice();
+        uint256 previousPrice = IOracle(poolOracle).getPrice();
 
         // Perform swap to OLAS
-        olasAmount = _performSwap(nativeTokenAmount);
+        olasAmount = _performSwap(secondToken, secondTokenAmount, poolOracle);
 
         // Get current pool price
-        uint256 tradePrice = IOracle(oracle).getPrice();
+        uint256 tradePrice = IOracle(poolOracle).getPrice();
 
         // Validate against slippage thresholds
         uint256 lowerBound = (previousPrice * (100 - maxSlippage)) / 100;
@@ -179,11 +197,11 @@ abstract contract BuyBackBurner {
     }
 
     /// @dev Buys OLAS on V3 DEX.
-    /// @param token Token address.
-    /// @param tokenAmount Token amount.
+    /// @param secondToken Second token address.
+    /// @param secondTokenAmount Second token amount.
     /// @param feeTierOrTickSpacing Fee tier or tick spacing.
     /// @return olasAmount Obtained OLAS amount.
-    function _buyOLAS(address token, uint256 tokenAmount, int24 feeTierOrTickSpacing)
+    function _buyOLAS(address secondToken, uint256 secondTokenAmount, int24 feeTierOrTickSpacing)
         internal
         virtual
         returns (uint256 olasAmount)
@@ -191,7 +209,7 @@ abstract contract BuyBackBurner {
         address localOlas = olas;
 
         address[] memory tokens = new address[](2);
-        (tokens[0], tokens[1]) = (token > localOlas) ? (localOlas, token) : (token, localOlas);
+        (tokens[0], tokens[1]) = (secondToken > localOlas) ? (localOlas, secondToken) : (secondToken, localOlas);
 
         // Get factory from LiquidityManager
         // Actual factoryV3 is fetched from LiquiditiManager, since LiquiditiManager is proxy and factory might change
@@ -200,16 +218,16 @@ abstract contract BuyBackBurner {
         // Get V3 pool from liquidity manager
         address pool = getV3Pool(factoryV3, tokens, feeTierOrTickSpacing);
 
-        // Check for zero address
-        if (pool == address(0)) {
-            revert ZeroAddress();
+        // Check for whitelisted pool address
+        if (!mapV3Pools[pool]) {
+            revert UnauthorizedPool(pool);
         }
 
         // Apply slippage protection
         ILiquidityManager(liquidityManager).checkPoolAndGetCenterPrice(pool);
 
         // Perform swap to OLAS
-        olasAmount = _performSwap(token, tokenAmount, feeTierOrTickSpacing);
+        olasAmount = _performSwap(secondToken, secondTokenAmount, feeTierOrTickSpacing);
     }
 
     /// @dev BuyBackBurner initializer.
@@ -264,21 +282,33 @@ abstract contract BuyBackBurner {
         emit OwnerUpdated(newOwner);
     }
 
-    /// @dev Changes contract oracle address for a specific V2-like full range pool.
-    /// @param newOracle Address of a new oracle.
-    function changeOracle(address newOracle) external virtual {
+    /// @dev Changes V2 oracle addresses for a specific V2-like full range pools based on second token.
+    /// @param secondTokens Set of second tokens.
+    /// @param oracles Set of corresponding oracle addresses.
+    function changeV2Oracles(address[] memory secondTokens, address[] memory oracles) external virtual {
         // Check for the ownership
         if (msg.sender != owner) {
             revert OwnerOnly(msg.sender, owner);
         }
 
-        // Check for the zero address
-        if (newOracle == address(0)) {
-            revert ZeroAddress();
+        uint256 numPools = secondTokens.length;
+        
+        // Check for array sizes
+        if (numPools == 0 || numPools != oracles.length) {
+            revert();
+        }
+        
+        // Process data
+        for (uint256 i = 0; i < numPools; ++i) {
+            // Check for zero addresses
+            if (secondTokens[i] == address(0) || oracles[i] == address(0)) {
+                revert ZeroAddress();
+            }
+
+            mapV2Oracles[secondTokens[i]] = oracles[i];
         }
 
-        oracle = newOracle;
-        emit OracleUpdated(newOracle);
+        emit OraclesUpdated(secondTokens, oracles);
     }
 
     /// @dev Checks pool prices via Uniswap V3 built-in oracle.
@@ -305,26 +335,27 @@ abstract contract BuyBackBurner {
     }
 
     /// @dev Buys OLAS on V2 DEX.
-    /// @notice if nativeTokenAmount is zero or above the balance, it will be adjusted to current native token balance.
-    /// @param nativeTokenAmount Suggested native token amount.
-    function buyBack(uint256 nativeTokenAmount) external virtual {
+    /// @notice if secondTokenAmount is zero or above the balance, it will be adjusted to current second token balance.
+    /// @param secondToken Second token address.
+    /// @param secondTokenAmount Suggested second token amount.
+    function buyBack(address secondToken, uint256 secondTokenAmount) external virtual {
         // Reentrancy guard
         if (_locked > 1) {
             revert ReentrancyGuard();
         }
         _locked = 2;
 
-        address localNativeToken = nativeToken;
+        address localSecondToken = secondToken;
 
-        // Get nativeToken balance
-        uint256 balance = IERC20(localNativeToken).balanceOf(address(this));
+        // Get secondToken balance
+        uint256 balance = IERC20(localSecondToken).balanceOf(address(this));
 
-        // Adjust native token amount, if needed
-        if (nativeTokenAmount == 0 || nativeTokenAmount > balance) {
-            nativeTokenAmount = balance;
+        // Adjust second token amount, if needed
+        if (secondTokenAmount == 0 || secondTokenAmount > balance) {
+            secondTokenAmount = balance;
         }
 
-        if (nativeTokenAmount == 0) {
+        if (secondTokenAmount == 0) {
             revert ZeroValue();
         }
 
@@ -332,9 +363,9 @@ abstract contract BuyBackBurner {
         mapAccountActivities[msg.sender]++;
 
         // Buy OLAS
-        uint256 olasAmount = _buyOLAS(nativeTokenAmount);
+        uint256 olasAmount = _buyOLAS(secondToken, secondTokenAmount);
 
-        emit BuyBack(localNativeToken, nativeTokenAmount, olasAmount);
+        emit BuyBack(localSecondToken, secondTokenAmount, olasAmount);
 
         // Get OLAS contract balance
         olasAmount = IERC20(olas).balanceOf(address(this));
@@ -348,11 +379,11 @@ abstract contract BuyBackBurner {
     }
 
     /// @dev Buys OLAS on V3 DEX.
-    /// @notice if tokenAmount is zero or above the balance, it will be adjusted to current native token balance.
-    /// @param token Token address.
-    /// @param tokenAmount Suggested token amount.
+    /// @notice if secondTokenAmount is zero or above the balance, it will be adjusted to current second token balance.
+    /// @param secondToken Second token address.
+    /// @param secondTokenAmount Suggested second token amount.
     /// @param feeTierOrTickSpacing Fee tier or tick spacing.
-    function buyBack(address token, uint256 tokenAmount, int24 feeTierOrTickSpacing) external virtual {
+    function buyBack(address secondToken, uint256 secondTokenAmount, int24 feeTierOrTickSpacing) external virtual {
         // Reentrancy guard
         if (_locked > 1) {
             revert ReentrancyGuard();
@@ -360,14 +391,14 @@ abstract contract BuyBackBurner {
         _locked = 2;
 
         // Get token balance
-        uint256 balance = IERC20(token).balanceOf(address(this));
+        uint256 balance = IERC20(secondToken).balanceOf(address(this));
 
-        // Adjust native token amount, if needed
-        if (tokenAmount == 0 || tokenAmount > balance) {
-            tokenAmount = balance;
+        // Adjust second token amount, if needed
+        if (secondTokenAmount == 0 || secondTokenAmount > balance) {
+            secondTokenAmount = balance;
         }
 
-        if (tokenAmount == 0) {
+        if (secondTokenAmount == 0) {
             revert ZeroValue();
         }
 
@@ -375,9 +406,9 @@ abstract contract BuyBackBurner {
         mapAccountActivities[msg.sender]++;
 
         // Buy OLAS
-        uint256 olasAmount = _buyOLAS(token, tokenAmount, feeTierOrTickSpacing);
+        uint256 olasAmount = _buyOLAS(secondToken, secondTokenAmount, feeTierOrTickSpacing);
 
-        emit BuyBack(token, tokenAmount, olasAmount);
+        emit BuyBack(secondToken, secondTokenAmount, olasAmount);
 
         // Get OLAS contract balance
         olasAmount = IERC20(olas).balanceOf(address(this));
@@ -385,7 +416,7 @@ abstract contract BuyBackBurner {
         // Transfer OLAS to bridge2Burner contract
         IERC20(olas).transfer(bridge2Burner, olasAmount);
 
-        emit TokenTransferred(bridge2Burner, tokenAmount);
+        emit TokenTransferred(bridge2Burner, secondTokenAmount);
 
         _locked = 1;
     }
@@ -403,6 +434,7 @@ abstract contract BuyBackBurner {
     }
 
     /// @dev Transfers specified token to treasury.
+    /// @param token Token address.
     function transfer(address token) external {
         // Get token amount
         uint256 tokenAmount = IERC20(token).balanceOf(address(this));
diff --git a/contracts/utils/BuyBackBurnerBalancer.sol b/contracts/utils/BuyBackBurnerBalancer.sol
index 9e3b776f..ddf6feb0 100644
--- a/contracts/utils/BuyBackBurnerBalancer.sol
+++ b/contracts/utils/BuyBackBurnerBalancer.sol
@@ -72,6 +72,15 @@ interface IERC20 {
     function approve(address spender, uint256 amount) external returns (bool);
 }
 
+// Oracle V2 interface
+interface IOracle {
+    /// @dev Gets balancer vault address.
+    function balancerVault() external view returns (address);
+
+    /// @dev Gets balancer pool Id.
+    function balancerPoolId() external view returns (bytes32);
+}
+
 /// @title BuyBackBurnerBalancer - BuyBackBurner implementation contract for interaction with Balancer for V2-like
 ///        full range pools and Slipstream for V3-like concentrated liquidity pools
 contract BuyBackBurnerBalancer is BuyBackBurner {
@@ -90,43 +99,51 @@ contract BuyBackBurnerBalancer is BuyBackBurner {
     {}
 
     /// @dev Performs swap for OLAS on Balancer DEX.
-    /// @param nativeTokenAmount Native token amount.
+    /// @param secondToken Second token address.
+    /// @param secondTokenAmount Second token amount.
+    /// @param poolOracle Pool oracle address.
     /// @return olasAmount Obtained OLAS amount.
-    function _performSwap(uint256 nativeTokenAmount) internal virtual override returns (uint256 olasAmount) {
-        // Approve nativeToken for the Balancer Vault
-        IERC20(nativeToken).approve(balancerVault, nativeTokenAmount);
+    function _performSwap(address secondToken, uint256 secondTokenAmount, address poolOracle) internal virtual override returns (uint256 olasAmount) {
+        // Get balancer vault address
+        address balVault = IOracle(poolOracle).balancerVault();
+
+        // Get balancer pool Id
+        bytes32 balPoolId = IOracle(poolOracle).balancerPoolId();
+
+        // Approve secondToken for the Balancer Vault
+        IERC20(secondToken).approve(balVault, secondTokenAmount);
 
-        // Prepare Balancer data for the nativeToken-OLAS pool
+        // Prepare Balancer data for the secondToken-OLAS pool
         IBalancer.SingleSwap memory singleSwap = IBalancer.SingleSwap(
-            balancerPoolId, IBalancer.SwapKind.GIVEN_IN, nativeToken, olas, nativeTokenAmount, "0x"
+            balPoolId, IBalancer.SwapKind.GIVEN_IN, secondToken, olas, secondTokenAmount, "0x"
         );
         IBalancer.FundManagement memory fundManagement =
             IBalancer.FundManagement(address(this), false, payable(address(this)), false);
 
         // Perform swap
-        olasAmount = IBalancer(balancerVault).swap(singleSwap, fundManagement, 0, block.timestamp);
+        olasAmount = IBalancer(balVault).swap(singleSwap, fundManagement, 0, block.timestamp);
     }
 
     /// @dev Performs swap for OLAS on Slipstream CL DEX.
-    /// @param token Token address.
-    /// @param tokenAmount Token amount.
+    /// @param secondToken Second token address.
+    /// @param secondTokenAmount Second token amount.
     /// @param tickSpacing Tick spacing.
     /// @return olasAmount Obtained OLAS amount.
-    function _performSwap(address token, uint256 tokenAmount, int24 tickSpacing)
+    function _performSwap(address secondToken, uint256 secondTokenAmount, int24 tickSpacing)
         internal
         virtual
         override
         returns (uint256 olasAmount)
     {
-        IERC20(token).approve(swapRouter, tokenAmount);
+        IERC20(secondToken).approve(swapRouter, secondTokenAmount);
 
         ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
-            tokenIn: token,
+            tokenIn: secondToken,
             tokenOut: olas,
             tickSpacing: tickSpacing,
             recipient: address(this),
             deadline: block.timestamp,
-            amountIn: tokenAmount,
+            amountIn: secondTokenAmount,
             amountOutMinimum: 1,
             sqrtPriceLimitX96: 0
         });
diff --git a/contracts/utils/BuyBackBurnerUniswap.sol b/contracts/utils/BuyBackBurnerUniswap.sol
index 728a5d78..00090829 100644
--- a/contracts/utils/BuyBackBurnerUniswap.sol
+++ b/contracts/utils/BuyBackBurnerUniswap.sol
@@ -75,19 +75,20 @@ contract BuyBackBurnerUniswap is BuyBackBurner {
     {}
 
     /// @dev Performs swap for OLAS on DEX.
-    /// @param nativeTokenAmount Native token amount.
+    /// @param secondToken Second token address.
+    /// @param secondTokenAmount Second token amount.
     /// @return olasAmount Obtained OLAS amount.
-    function _performSwap(uint256 nativeTokenAmount) internal virtual override returns (uint256 olasAmount) {
-        // Approve nativeToken for the router
-        IERC20(nativeToken).approve(router, nativeTokenAmount);
+    function _performSwap(address secondToken, uint256 secondTokenAmount, address) internal virtual override returns (uint256 olasAmount) {
+        // Approve secondToken for the router
+        IERC20(secondToken).approve(router, secondTokenAmount);
 
         address[] memory path = new address[](2);
-        path[0] = nativeToken;
+        path[0] = secondToken;
         path[1] = olas;
 
-        // Swap nativeToken for OLAS
+        // Swap secondToken for OLAS
         uint256[] memory amounts =
-            IUniswap(router).swapExactTokensForTokens(nativeTokenAmount, 0, path, address(this), block.timestamp);
+            IUniswap(router).swapExactTokensForTokens(secondTokenAmount, 0, path, address(this), block.timestamp);
 
         // Record OLAS amount
         olasAmount = amounts[1];

From 77b6b3adb120c2c5bae0c255692f32e0b94221f9 Mon Sep 17 00:00:00 2001
From: Aleksandr Kuperman <aleksandr.kuperman@valory.xyz>
Date: Tue, 6 Jan 2026 15:48:17 +0000
Subject: [PATCH 2/6] feat: set v3 pool statuses

---
 contracts/utils/BuyBackBurner.sol | 48 ++++++++++++++++++++++++++-----
 1 file changed, 41 insertions(+), 7 deletions(-)

diff --git a/contracts/utils/BuyBackBurner.sol b/contracts/utils/BuyBackBurner.sol
index d369ac22..35456b6c 100644
--- a/contracts/utils/BuyBackBurner.sol
+++ b/contracts/utils/BuyBackBurner.sol
@@ -56,6 +56,9 @@ error ZeroValue();
 /// @dev The contract is already initialized.
 error AlreadyInitialized();
 
+/// @dev Wrong array length.
+error WrongArrayLength();
+
 /// @dev Unauthorized pool address.
 /// @param pool Pool address.
 error UnauthorizedPool(address pool);
@@ -68,6 +71,7 @@ abstract contract BuyBackBurner {
     event ImplementationUpdated(address indexed implementation);
     event OwnerUpdated(address indexed owner);
     event OraclesUpdated(address[] secondTokens, address[] oracles);
+    event V3PoolStatusesUpdated(address[] pools, bool[] statuses);
     event BuyBack(address indexed secondToken, uint256 secondTokenAmount, uint256 olasAmount);
     event OraclePriceUpdated(address indexed oracle, address indexed sender);
     event TokenTransferred(address indexed destination, uint256 amount);
@@ -282,10 +286,10 @@ abstract contract BuyBackBurner {
         emit OwnerUpdated(newOwner);
     }
 
-    /// @dev Changes V2 oracle addresses for a specific V2-like full range pools based on second token.
+    /// @dev Sets V2 oracle addresses for a specific V2-like full range pools based on second token.
     /// @param secondTokens Set of second tokens.
     /// @param oracles Set of corresponding oracle addresses.
-    function changeV2Oracles(address[] memory secondTokens, address[] memory oracles) external virtual {
+    function setV2Oracles(address[] memory secondTokens, address[] memory oracles) external virtual {
         // Check for the ownership
         if (msg.sender != owner) {
             revert OwnerOnly(msg.sender, owner);
@@ -295,7 +299,7 @@ abstract contract BuyBackBurner {
         
         // Check for array sizes
         if (numPools == 0 || numPools != oracles.length) {
-            revert();
+            revert WrongArrayLength();
         }
         
         // Process data
@@ -311,6 +315,35 @@ abstract contract BuyBackBurner {
         emit OraclesUpdated(secondTokens, oracles);
     }
 
+    /// @dev Sets V3 pool statuses.
+    /// @param pools Set of V3 pools.
+    /// @param statuses Set of corresponding pool statuses.
+    function setV2Oracles(address[] memory pools, bool[] memory statuses) external virtual {
+        // Check for the ownership
+        if (msg.sender != owner) {
+            revert OwnerOnly(msg.sender, owner);
+        }
+
+        uint256 numPools = pools.length;
+
+        // Check for array sizes
+        if (numPools == 0 || numPools != statuses.length) {
+            revert WrongArrayLength();
+        }
+
+        // Process data
+        for (uint256 i = 0; i < numPools; ++i) {
+            // Check for zero addresses
+            if (pools[i] == address(0)) {
+                revert ZeroAddress();
+            }
+
+            mapV3Pools[pools[i]] = statuses[i];
+        }
+
+        emit V3PoolStatusesUpdated(pools, statuses);
+    }
+
     /// @dev Checks pool prices via Uniswap V3 built-in oracle.
     /// @notice This is a legacy function for compatibility with one of apps, it accounts for UniswapV3 only.
     /// @param token0 Token0 address.
@@ -421,16 +454,17 @@ abstract contract BuyBackBurner {
         _locked = 1;
     }
 
-    /// @dev Triggers oracle price update.
-    function updateOraclePrice() external {
+    /// @dev Triggers V2 oracle price update.
+    /// @param poolOracle Pool oracle address.
+    function updateOraclePrice(address poolOracle) external {
         // Record msg.sender activity
         mapAccountActivities[msg.sender]++;
 
         // Update price
-        bool success = IOracle(oracle).updatePrice();
+        bool success = IOracle(poolOracle).updatePrice();
         require(success, "Oracle price update failed");
 
-        emit OraclePriceUpdated(oracle, msg.sender);
+        emit OraclePriceUpdated(poolOracle, msg.sender);
     }
 
     /// @dev Transfers specified token to treasury.

From 16a30b241f8f82020bf73f5f56073df39404ed17 Mon Sep 17 00:00:00 2001
From: Aleksandr Kuperman <aleksandr.kuperman@valory.xyz>
Date: Tue, 6 Jan 2026 15:55:16 +0000
Subject: [PATCH 3/6] test: fix forge tests

---
 test/BuyBackBurnerBalancerBase.t.sol | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/test/BuyBackBurnerBalancerBase.t.sol b/test/BuyBackBurnerBalancerBase.t.sol
index e1d69f17..9642e6b1 100644
--- a/test/BuyBackBurnerBalancerBase.t.sol
+++ b/test/BuyBackBurnerBalancerBase.t.sol
@@ -106,6 +106,13 @@ contract BaseSetup is Test {
 
         // Wrap proxy into implementation
         buyBackBurnerBalancer = BuyBackBurnerBalancer(address(buyBackBurnerProxy));
+
+        address[] memory secondTokens = new address[](1);
+        secondTokens[0] = WETH;
+        address[] memory oracles = new address[](1);
+        oracles[0] = address(oracleV2);
+        // Set oracle for V2 swaps
+        buyBackBurnerBalancer.setV2Oracles(secondTokens, oracles);
     }
 }
 
@@ -120,7 +127,7 @@ contract BuyBackBurnerBalancerBase is BaseSetup {
         deal(WETH, address(buyBackBurnerBalancer), 1 ether);
 
         // Swap for OLAS
-        buyBackBurnerBalancer.buyBack(1 ether);
+        buyBackBurnerBalancer.buyBack(WETH, 1 ether);
 
         // Bridge OLAS to burn
         bridge2Burner.relayToL1Burner();

From e3e75d4f8faa0bf090d5ceb3b4647b6f112caa4c Mon Sep 17 00:00:00 2001
From: Aleksandr Kuperman <aleksandr.kuperman@valory.xyz>
Date: Tue, 6 Jan 2026 16:22:54 +0000
Subject: [PATCH 4/6] chore: space

---
 contracts/utils/BuyBackBurner.sol | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/contracts/utils/BuyBackBurner.sol b/contracts/utils/BuyBackBurner.sol
index 35456b6c..b096a1bc 100644
--- a/contracts/utils/BuyBackBurner.sol
+++ b/contracts/utils/BuyBackBurner.sol
@@ -179,7 +179,7 @@ abstract contract BuyBackBurner {
         address poolOracle = mapV2Oracles[secondToken];
 
         // Check for zero address
-        require (poolOracle != address(0), "Zero oracle address");
+        require(poolOracle != address(0), "Zero oracle address");
 
         // Apply slippage protection
         require(IOracle(poolOracle).validatePrice(maxSlippage), "Before swap slippage limit is breached");

From 76b135d4d56df78daf3030103da3fc3138fc7204 Mon Sep 17 00:00:00 2001
From: Aleksandr Kuperman <aleksandr.kuperman@valory.xyz>
Date: Tue, 6 Jan 2026 16:55:14 +0000
Subject: [PATCH 5/6] chore: function name change

---
 contracts/utils/BuyBackBurner.sol | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/contracts/utils/BuyBackBurner.sol b/contracts/utils/BuyBackBurner.sol
index b096a1bc..660ab427 100644
--- a/contracts/utils/BuyBackBurner.sol
+++ b/contracts/utils/BuyBackBurner.sol
@@ -318,7 +318,7 @@ abstract contract BuyBackBurner {
     /// @dev Sets V3 pool statuses.
     /// @param pools Set of V3 pools.
     /// @param statuses Set of corresponding pool statuses.
-    function setV2Oracles(address[] memory pools, bool[] memory statuses) external virtual {
+    function setV3PoolStatuses(address[] memory pools, bool[] memory statuses) external virtual {
         // Check for the ownership
         if (msg.sender != owner) {
             revert OwnerOnly(msg.sender, owner);

From 43430444d9bdb73f7841cc9c1ac2a5efb19b40b8 Mon Sep 17 00:00:00 2001
From: Aleksandr Kuperman <95347597+kupermind@users.noreply.github.com>
Date: Wed, 7 Jan 2026 14:52:41 +0000
Subject: [PATCH 6/6] Update contracts/utils/BuyBackBurner.sol

Co-authored-by: Pi <93650028+mariapiamo@users.noreply.github.com>
---
 contracts/utils/BuyBackBurner.sol | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/contracts/utils/BuyBackBurner.sol b/contracts/utils/BuyBackBurner.sol
index 660ab427..4c74cbc8 100644
--- a/contracts/utils/BuyBackBurner.sol
+++ b/contracts/utils/BuyBackBurner.sol
@@ -216,7 +216,7 @@ abstract contract BuyBackBurner {
         (tokens[0], tokens[1]) = (secondToken > localOlas) ? (localOlas, secondToken) : (secondToken, localOlas);
 
         // Get factory from LiquidityManager
-        // Actual factoryV3 is fetched from LiquiditiManager, since LiquiditiManager is proxy and factory might change
+        // Actual factoryV3 is fetched from LiquidityManager, since LiquidityManager is proxy and factory might change
         address factoryV3 = ILiquidityManager(liquidityManager).factoryV3();
 
         // Get V3 pool from liquidity manager
